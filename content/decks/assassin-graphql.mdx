import { Head, Split, Notes } from "gatsby-theme-mdx-deck"

<Head>
  <title>Assassinating GraphQL</title>
</Head>

# Assassinating GraphQL

## With React Hooks, Apollo, and ‚ù§

---

<Split>

# @ralex1993

![/me.jpg](/avatar.jpg)

</Split>

<Notes>
  Hi there! My Name is Alex. You can find me on Twitter @ralex1993. Yes that is
  my birth year. Sorry if that makes you feel old; sorry if that makes you feel
  young. And today we're going to talk about GraphQL and the game Assassin.
</Notes>

---

# GraphQL

## A query language for your API

<Notes>
  GraphQL is a hot new tech - we just heared about it in the last session.
</Notes>

---

> It's an organization layer that you can put in front of all of your data sources, and then get exactly the data you want.

<cite>Eve Porcello</cite>

---

```json
{
  "data": {
    "person": {
      "name": "Darth Vader",
      "birthYear": "41.9BBY",
      "planet": {
        "name": "Tatooine"
      },
      "films": [
        { "title": "A New Hope" },
        { "title": "The Empire Strikes Back" },
        { "title": "Return of the Jedi" },
        { "title": "Revenge of the Sith" }
      ]
    }
  }
}
```

---

```json
{
  "data": {
    "person": {
      ‚Äúname":
      "birthYear"
      "planet": {
        "name"
      },
      "films": [
        { ‚Äútitle" }



      ]
    }
  }
}
```

---

```GraphQL
query StarWarsPerson {
 person(personID: 4) {
    name,
    birthYear,
    homeworld {
      name
    },
    filmConnection {
      films {
        title
      }
    }
  }
}
```

---

- **Queries**: Get data
- **Mutations**: Change data
- **Subscriptions**: Get updates

---

- One Endpoint
- Single request - lots of data
- Statically Typed
- Auto-documented

---

# React Hooks

- Use in function components
- "Hook" into state and lifecycle
- Reusable and composable

---

# Assassin

<Notes>
  Assassin can be considered a live-action roleplaying game where a large group
  of people try to eliminate each other. Typically this game is facilitated by a
  non-player moderator, but today we're going to work on an app that can
  facilitate the game for us.
</Notes>

---

![/assassin1.svg](/assassin1.svg)

<Notes>
  Suppose I start a game. I can't play it by myself, I have to invite a bunch of
  friends.
</Notes>

---

![/assassin2.svg](/assassin2.svg)

<Notes>
  All of us log into the app in a way that we are personally identified. It
  helps if everyone knows each other, because we'll have to use the information
  which the app gives us to find and eliminate our target. The target is
  assigned by the app.
</Notes>

---

![/assassin3.svg](/assassin3.svg)

<Notes>
  Targets are assigned in a round-robin. So, I'll be given a target. That's the
  person that I'm supposed to eliminate. Only I know who my target is; nobody
  else knows, unless I give it away.
</Notes>

---

![/assassin4.svg](/assassin4.svg)

<Notes>My target will also be given a target.</Notes>

---

![/assassin5.svg](/assassin5.svg)

<Notes>
  And so on until everyone has a target and everyone is a target. Even I will
  have a target, though I won't know who my target is.
</Notes>

---

![/assassin6.svg](/assassin6.svg)

<Notes>
  Once everyone has a target and the game starts, we can eliminate each other.
  You can do this by gently poking with a spoon, or maybe everyone has to wear a
  clothespin on their sleeve and you eliminate someone by taking their
  clothespin. Either way, once someone is eliminated, they have to surrender on
  the app.
</Notes>

---

![/assassin7.svg](/assassin7.svg)

<Notes>
  Surrendering removes them from the game, and assigns their target to me. Now I
  have to find and eliminate their target. The game keeps going until there is
  only one player left, at which point that player is declared the winner!
</Notes>

---

# GraphQL

<Notes>
  Now that we know how the game works, we can talk about how it's made. In this
  case, we'll be using GraphQL to facilitate the communication between the
  client and the server. There are three things which GraphQL allows us to do.
</Notes>

---

# Queries

```GraphQL
query Games {
  games {
    id
    name
    description
    completed
  }
}
```

<Notes>
  First, we can query for data. This is supposed to be a read-only operation.
  This query gives us a list of games, including the name, description, and
  whether the game is completed.
</Notes>

---

```json
{
  "data": {
    "games": [
      {
        "id": "3fa93991-a84b-4c12-b10b-90ef94ce5e46",
        "name": "UtahJS Assassin",
        "completed": false,
        "description": "A friendly game, just gently poke with a spoon to win."
      }
    ]
  }
}
```

<Notes>
  When our query resolves, it gives us exactly the data we ask for, and no more.
  That's the beauty of GraphQL - it only gives us what we ask for, which in many
  cases can ease the load on the API server.
</Notes>

---

# Mutations

```GraphQL
mutation Surrender($gameId: ID!) {
  surrender(gameId: $gameId) {
    id
    me {
      id
      dead
    }
  }
}

```

<Notes>
  Mutations operate much like queries, except they are only used for
  write-operations. This includes creating, updating, and deleting records as
  well as triggering events. This mutation allows a player to surrender in the
  current game. Notice that I provide the ID of the game that I am surrendering
  in. The response includes the game ID and my player information, including a
  boolean for whether I am dead or not. I can use that to update the UI to
  indicate that I lost the game.
</Notes>

---

# Subscriptions

```GraphQL
subscription GameList($gameId: ID!) {
  gameUpdate(gameId: $gameId) {
    id
    name
    playerCount
    aliveCount
  }
}

```

<Notes>
  Subscriptions are for real-time data. This allows the server to send updates
  and information to the client at any time. This usually happens in response to
  another client performing a mutation. This subscription updates the number of
  active players. Notice that I can provide a game ID which limits the
  subscription responses I get to only those corresponding to that game. Clients
  will get this subscription data if someone in that game surrenders, decreasing
  the number of active players.
</Notes>

---

# Demo

## GraphQL Playground

<Notes>
  Lets take some of these queries and try them out on our GraphQL server. Apollo
  Server comes with GraphQL playgrounds, which is a simple IDE for writing and
  executing GraphQL requests.
</Notes>

---

- CURL/Fetch
- Relay
- Lokka
- URQL
- React Apollo

<Notes>
  There are a lot of ways we can consume GraphQL APIs. Since it is just HTTP and
  WebSockets, anything that speaks HTTP can use a GraphQL server. There are some
  nice client libraries, like Lokka, URQL, and Relay that add caching and other
  niceties. But today, we'll use React Apollo, because of their really nice new
  hooks API.
</Notes>

---

# Setting Up Apollo

https://www.apollographql.com/docs/react/essentials/get-started/

https://www.apollographql.com/docs/react/advanced/subscriptions/

<Notes>
  I'm not going to cover how to set up Apollo on your project - the
  documentation is really good and you should be able to figure it out yourself.
  Note that setting up subscriptions takes a bit more effort.
</Notes>

---

# Apollo Hooks

- `useQuery`
- `useMutation`
- `useSubscription`
- `useSubscribeToMore`\*

\* A custom hook

<Notes>
  Here are the hooks we are going to be playing with. We'll useQuery to get the
  list of games for a user; useMutation for surrendering during a game, and
  useSubscription for showing a toast notification when an action happens during
  a game. useSubscribeToMore is a special hook which I created which allows us
  to use the subscribeToMore function which Apollo provides to declaratively
  subscribe to and update query data.
</Notes>

---

# Demo

## `useQuery`

---

# Demo

## `useMutation`

---

# Demo

## `useSubscription`

---

# Demo

## `useSubscribeToMore`

---

# What about testing?

## Use `<MockedProvider>`

<Notes>
  Apollo has a MockedProvider component which you can use to test your Apollo
  powered components in isolation. Just give the provider some mocked data, and
  you can simulate any network response as if it were coming directly from the
  server. You can use this in storybook pages or as part of your Jest/React
  Testing Library tests.
</Notes>

---

# Conclusion

- GraphQL is great!
- Hooks are awesome!

---

## Thanks üôå

<https://twitter.com/ralex1993>
